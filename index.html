<!doctype html>
<meta charset="utf-8">
<title>Make a sprite from a texture atlas </title>

<body>
  <script src="pixi/pixi.min.js"></script>
  <script src="Cooper.js"></script>
  <script src="George.js"></script>
  <script src="James.js"></script>
  <script src="Sam.js"></script>
  <script src="Sally.js"></script>
  <script src="Sara.js"></script>
  <script src="Monster.js"></script>
  <script src="BlueRoom.js"></script>
  <script src="RedRoom.js"></script>
  <script src="GreenRoom.js"></script>
  <script src="YellowRoom.js"></script>
  <script>

    //Aliases
    let Application = PIXI.Application,
      Container = PIXI.Container,
      loader = PIXI.loader,
      resources = PIXI.loader.resources,
      Graphics = PIXI.Graphics,
      TextureCache = PIXI.TextureCache,
      Sprite = PIXI.Sprite,
      Text = PIXI.Text,
      TextStyle = PIXI.TextStyle;

    //Create a Pixi Application
    let app = new Application({
      width: 512,
      height: 512,
      antialiasing: true,
      transparent: false,
      resolution: 1
    }
    );

    //Add the canvas that Pixi automatically created for you to the HTML document
    document.body.appendChild(app.view);

    //load a JSON file and run the `setup` function when it's done
    loader
      .add("images/treasureHunter.json")
      .add("images/Cooper.json")
      .add("images/George.json")
      .add("images/James.json")
      .add("images/Sam & Sally.json")
      .add("images/Sara.json")
      .add("images/Monster.json")
      .add("images/Floors.json")
      .load(setup);

    //Define variables that might be used in more than one function
    let state, cooper, treasure, blobs, chimes, exit, player, dungeon,
      door, healthBar, message, gameScene, gameOverScene, enemies, id;

    function setup() {

      //Make the game scene and add it to the stage 
      gameScene = new Container();
      app.stage.addChild(gameScene);

      //Make the sprites and add them to the `gameScene`
      //Create an alias for the texture atlas frame ids
      id = resources["images/treasureHunter.json"].textures;


      //Dungeon
      //dungeon = new Sprite(id["dungeon.png"]);
      //gameScene.addChild(dungeon);
      blue = new BlueRoom(resources,gameScene);
      red = new RedRoom(resources,gameScene);
      green = new GreenRoom(resources,gameScene);
      yellow = new YellowRoom(resources,gameScene);

      
      //explorer = new Sprite(Cooper["sprite79"]);
      //explorer.x = 68;
      //explorer.y = gameScene.height / 2 - explorer.height / 2;
      //explorer.vx = 0;
      //explorer.vy = 0;
      //gameScene.addChild(explorer);
      cooper = new Cooper(resources, gameScene, 68, gameScene.height / 2);
      george = new George(resources, gameScene);
      james = new James(resources, gameScene);
      //Scale sam & sally?
      sam = new Sam(resources, gameScene);
      sally = new Sally(resources, gameScene);
      sara = new Sara(resources, gameScene);
      monster = new Monster(resources, gameScene);

      
      
      //Create the `gameOver` scene
      gameOverScene = new Container();
      app.stage.addChild(gameOverScene);

      //Make the `gameOver` scene invisible when the game first starts
      gameOverScene.visible = false;

      //Create the text sprite and add it to the `gameOver` scene
      let style = new TextStyle({
        frontFamily: "Futura",
        frontSize: 64,
        fill: "White"
      });
      message = new Text("The End!", style);
      message.x = 120;
      message.y = app.stage.height / 2 - 32;
      gameOverScene.addChild(message);

      //Capture the keyboard arrow keys
      let left = keyboard(37),
        up = keyboard(38),
        right = keyboard(39),
        down = keyboard(40);

      //Left arrow key `press` method
      left.press = function () {

        //Change the Cooper's velocity when the key is pressed
        cooper.vx = -5;
        cooper.vy = 0;
      };

      //Left arrow key `release` method
      left.release = function () {

        //If the left arrow has been released, and the right arrow isn't down,
        //and the Cooper isn't moving vertically:
        //Stop the Cooper
        if (!right.isDown && cooper.animation.vy === 0) {
          cooper.animation.vx = 0;
        }
      };

      //Up
      up.press = function () {
        explorer.vy = -5;
        explorer.vx = 0;
      };
      up.release = function () {
        if (!down.isDown && explorer.vx === 0) {
          explorer.vy = 0;
        }
      };

      //Right
      right.press = function () {
        explorer.vx = 5;
        explorer.vy = 0;
      };
      right.release = function () {
        if (!left.isDown && explorer.vy === 0) {
          explorer.vx = 0;
        }
      };

      //Down
      down.press = function () {
        explorer.vy = 5;
        explorer.vx = 0;
      };
      down.release = function () {
        if (!up.isDown && explorer.vx === 0) {
          explorer.vy = 0;
        }
      };

      //Set the game state
      state = play;

      //Start the game loop
      app.ticker.add(delta => gameLoop(delta))
    };

    function gameLoop(delta) {

      //Update the current game state:
      state(delta);
    }

    function play(delta) {

      //use the explorer's velocity to make it move
      cooper.x += cooper.animation.vx;
      cooper.y += cooper.animation.vy;

      //Contain the explorer inside the area of the dungeon
      contain(cooper, { x: -3, y: -5, width: 515, height: 500 });
      //contain(explorer, stage);

      //Set `explorerHit` to `false` before checking for a collision
      let explorerHit = false;

      //Loop through all the sprites in the `enemies` array
      

      //If the explorer is hit...
      if (explorerHit) {

        //Make the  explorer semi-transparent
        explorer.alpha = 0.5;

        //Reduce the width of the health bar's inner rectangle by 1 pixle
        healthBar.outer.width -= 1;
      } else {

        //Make the explorer fully opaque (non-transparent) if it hasn't been hit
        cooper.alpha = 1;
      }

      //Check for a collision between the explorer and the treasure
      
    }

    function end() {
      gameScene.visible = false;
      gameOverScene.visible = true;
    }

    /* Helper functions */

    function contain(sprite, container) {

      let collision = undefined;

      //Left
      if (sprite.x < container.x) {
        sprite.x = container.x;
        collision = "left";
      }

      //Top
      if (sprite.y < container.y) {
        sprite.y = container.y;
        collision = "top";
      }

      //Right
      if (sprite.x + sprite.width > container.width) {
        sprite.x = container.width - sprite.width;
        collision = "right";
      }

      //Bottom
      if (sprite.y + sprite.height > container.height) {
        sprite.y = container.height - sprite.height;
        collision = "bottom";
      }

      //Return the `collision` value
      return collision;
    }

    //The `hitTestRectangle` function
    function hitTestRectangle(r1, r2) {

      //Defined the variables we'll need to calculate
      let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

      //hit will determine whether there,s a collision
      hit = false;

      //Find the center points of each sprite
      r1.centerX = r1.x + r1.width / 2;
      r1.centerY = r1.y + r1.height / 2;
      r2.centerX = r2.x + r2.width / 2;
      r2.centerY = r2.y + r2.height / 2;

      //Find the half-widths and half-heights of each sprite
      r1.halfWidth = r1.width / 2;
      r1.halfHeight = r1.height / 2;
      r2.halfWidth = r2.width / 2;
      r2.halfHeight = r2.height / 2;

      //Calculate the distance vector between the sprites
      vx = r1.centerX - r2.centerX;
      vy = r1.centerY - r2.centerY;

      //Figure out the combined half-widths and half-heights
      combinedHalfWidths = r1.halfWidth + r2.halfWidth;
      combinedHalfHeights = r1.halfHeight + r2.halfHeight;

      //Check for a collision on the x axis
      if (Math.abs(vx) < combinedHalfWidths) {

        //A collision might be occuring. Check for a collision on the y axis
        if (Math.abs(vy) < combinedHalfHeights) {

          //There's definitely a collision happening
          hit = true;
        } else {

          //There's no collision on the x axis
          hit = false;
        }
      } else {

        //There's no collision on the x axis
        hit = false;
      }

      //`hit` will either `true` or `false`
      return hit;
    };


    //The `randomInt` helper function
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    //The `keyboard` helper function
    function keyboard(keyCode) {
      var key = {};
      key.code = keyCode;
      key.isDown = false;
      key.isUp = true;
      key.press = undefined;
      key.release = undefined;

      //The `downHandler`
      key.downHandler = function (event) {
        if (event.keyCode === key.code) {
          if (key.isUp && key.press) key.press();
          key.isDown = true;
          key.isUp = false;
          event.preventDefault();
        }
      };

      //The `upHandler`
      key.upHandler = function (event) {
        if (event.keyCode === key.code) {
          if (key.isDown && key.release) key.release();
          key.isDown = false;
          key.isUp = true;
          event.preventDefault();
        }
      };

      //Attach event listeners
      window.addEventListener(
        "keydown", key.downHandler.bind(key), false
      );
      window.addEventListener(
        "keyup", key.upHandler.bind(key), false
      );

      return key;
    }
  </script>
</body>